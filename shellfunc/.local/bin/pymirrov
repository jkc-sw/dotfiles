#!/usr/bin/env python3
"""
Bitwarden to 1Password Multi-Folder Migration Script
Synchronizes items from multiple Bitwarden folders to 1Password employee vault.
Generated by Claude 4 Sonnet reasoning high with web search via t3.chat
"""

import json
import subprocess
import sys
import logging
import argparse
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum

try:
    from colorama import Fore, Style, init
    init(autoreset=True)
    COLORS_AVAILABLE = True
except ImportError:
    COLORS_AVAILABLE = False
    # Fallback color definitions
    class Fore:
        RED = GREEN = YELLOW = BLUE = CYAN = MAGENTA = ""
    class Style:
        RESET_ALL = ""

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


class ItemType(Enum):
    """Bitwarden item types"""
    LOGIN = 1
    SECURE_NOTE = 2
    CARD = 3
    IDENTITY = 4


class FieldType(Enum):
    """Bitwarden field types"""
    TEXT = 0
    HIDDEN = 1
    BOOLEAN = 2


@dataclass
class FolderStats:
    """Statistics for a single folder migration"""
    folder_name: str
    total_items: int = 0
    successful: int = 0
    failed: int = 0
    skipped: int = 0


@dataclass
class MigrationStats:
    """Overall migration statistics"""
    folder_stats: List[FolderStats] = field(default_factory=list)
    deleted_items: int = 0

    @property
    def total_items(self) -> int:
        return sum(stats.total_items for stats in self.folder_stats)

    @property
    def total_successful(self) -> int:
        return sum(stats.successful for stats in self.folder_stats)

    @property
    def total_failed(self) -> int:
        return sum(stats.failed for stats in self.folder_stats)

    @property
    def total_skipped(self) -> int:
        return sum(stats.skipped for stats in self.folder_stats)


@dataclass
class BitwardenFolder:
    """Represents a Bitwarden folder"""
    id: str
    name: str


@dataclass
class OnePasswordItem:
    """Represents a 1Password item"""
    id: str
    title: str
    vault: str
    tags: List[str] = field(default_factory=list)


class ColorLogger:
    """Enhanced logger with color support"""

    @staticmethod
    def info(message: str) -> None:
        if COLORS_AVAILABLE:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} {message}")
        else:
            print(f"[INFO] {message}")
        logger.info(message)

    @staticmethod
    def success(message: str) -> None:
        if COLORS_AVAILABLE:
            print(f"{Fore.GREEN}[SUCCESS]{Style.RESET_ALL} {message}")
        else:
            print(f"[SUCCESS] {message}")
        logger.info(message)

    @staticmethod
    def warning(message: str) -> None:
        if COLORS_AVAILABLE:
            print(f"{Fore.YELLOW}[WARNING]{Style.RESET_ALL} {message}")
        else:
            print(f"[WARNING] {message}")
        logger.warning(message)

    @staticmethod
    def error(message: str) -> None:
        if COLORS_AVAILABLE:
            print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} {message}")
        else:
            print(f"[ERROR] {message}")
        logger.error(message)

    @staticmethod
    def delete(message: str) -> None:
        if COLORS_AVAILABLE:
            print(f"{Fore.MAGENTA}[DELETE]{Style.RESET_ALL} {message}")
        else:
            print(f"[DELETE] {message}")
        logger.info(message)

    @staticmethod
    def folder_header(folder_name: str) -> None:
        if COLORS_AVAILABLE:
            print(f"\n{Fore.CYAN}{'='*60}")
            print(f"PROCESSING FOLDER: {folder_name}")
            print(f"{'='*60}{Style.RESET_ALL}")
        else:
            print(f"\n{'='*60}")
            print(f"PROCESSING FOLDER: {folder_name}")
            print(f"{'='*60}")

    @staticmethod
    def delete_header() -> None:
        if COLORS_AVAILABLE:
            print(f"\n{Fore.MAGENTA}{'='*60}")
            print(f"DELETING EXISTING ITEMS")
            print(f"{'='*60}{Style.RESET_ALL}")
        else:
            print(f"\n{'='*60}")
            print(f"DELETING EXISTING ITEMS")
            print(f"{'='*60}")


class CLIError(Exception):
    """Exception raised for CLI command errors"""
    pass


class BitwardenCLI:
    """Wrapper for Bitwarden CLI operations"""

    @staticmethod
    def run_command(command: List[str]) -> Dict[str, Any]:
        """Run a Bitwarden CLI command and return JSON result"""
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=True
            )
            return json.loads(result.stdout) if result.stdout.strip() else {}
        except subprocess.CalledProcessError as e:
            raise CLIError(f"Bitwarden CLI error: {e.stderr}")
        except json.JSONDecodeError as e:
            raise CLIError(f"Failed to parse Bitwarden CLI response: {e}")

    @staticmethod
    def check_auth() -> bool:
        """Check if Bitwarden CLI is authenticated and unlocked"""
        try:
            status = BitwardenCLI.run_command(['bw', 'status'])
            return status.get('status') == 'unlocked'
        except CLIError:
            return False

    @staticmethod
    def list_folders() -> List[BitwardenFolder]:
        """Get all folders from Bitwarden vault"""
        try:
            folders_data = BitwardenCLI.run_command(['bw', 'list', 'folders'])
            folders = []

            # Add "No Folder" option for items without a folder
            folders.append(BitwardenFolder(id=None, name="No Folder"))

            # Add actual folders
            for folder in folders_data:
                folders.append(BitwardenFolder(
                    id=folder.get('id'),
                    name=folder.get('name', 'Unnamed Folder')
                ))

            return folders
        except CLIError as e:
            raise CLIError(f"Failed to list folders: {e}")

    @staticmethod
    def find_folders_by_names(folder_names: List[str]) -> List[BitwardenFolder]:
        """Find multiple folders by names"""
        all_folders = BitwardenCLI.list_folders()
        found_folders = []
        missing_folders = []

        for folder_name in folder_names:
            folder_found = False
            for folder in all_folders:
                if folder.name.lower() == folder_name.lower():
                    found_folders.append(folder)
                    folder_found = True
                    break

            if not folder_found:
                missing_folders.append(folder_name)

        if missing_folders:
            available_names = [f.name for f in all_folders]
            raise CLIError(
                f"Folders not found: {', '.join(missing_folders)}. "
                f"Available folders: {', '.join(available_names)}"
            )

        return found_folders

    @staticmethod
    def list_items(folder_id: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get items from Bitwarden vault, optionally filtered by folder"""
        all_items = BitwardenCLI.run_command(['bw', 'list', 'items'])

        if folder_id is None:
            # Filter items that have no folder (folderId is null)
            return [item for item in all_items if item.get('folderId') is None]
        else:
            # Filter items by specific folder ID
            return [item for item in all_items if item.get('folderId') == folder_id]

    @staticmethod
    def sync() -> None:
        """Sync Bitwarden vault"""
        subprocess.run(['bw', 'sync'], check=True, capture_output=True)


class OnePasswordCLI:
    """Wrapper for 1Password CLI operations"""

    @staticmethod
    def run_command(command: List[str]) -> str:
        """Run a 1Password CLI command"""
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            raise CLIError(f"1Password CLI error: {e.stderr}")

    @staticmethod
    def check_auth() -> bool:
        """Check if 1Password CLI is authenticated"""
        try:
            OnePasswordCLI.run_command(['op', 'account', 'list'])
            return True
        except CLIError:
            return False

    @staticmethod
    def list_vaults() -> List[str]:
        """List available vaults"""
        try:
            output = OnePasswordCLI.run_command(['op', 'vault', 'list', '--format=json'])
            vaults = json.loads(output)
            return [vault['name'] for vault in vaults]
        except (CLIError, json.JSONDecodeError, KeyError):
            # Fallback to common vault names if listing fails
            return ["Private", "Employee", "Shared"]

    @staticmethod
    def list_items_by_tag(tag: str, vault: str = "Employee") -> List[OnePasswordItem]:
        """List items with a specific tag"""
        try:
            command = ['op', 'item', 'list', f'--vault={vault}', f'--tags={tag}', '--format=json']
            output = OnePasswordCLI.run_command(command)

            if not output.strip():
                return []

            items_data = json.loads(output)
            items = []

            for item_data in items_data:
                items.append(OnePasswordItem(
                    id=item_data.get('id', ''),
                    title=item_data.get('title', 'Untitled'),
                    vault=item_data.get('vault', {}).get('name', vault),
                    tags=item_data.get('tags', [])
                ))

            return items
        except (CLIError, json.JSONDecodeError) as e:
            raise CLIError(f"Failed to list items by tag '{tag}': {e}")

    @staticmethod
    def delete_item(item_id: str, vault: str = "Employee") -> None:
        """Delete an item by ID"""
        command = ['op', 'item', 'delete', item_id, f'--vault={vault}']
        OnePasswordCLI.run_command(command)

    @staticmethod
    def create_item(item_data: Dict[str, Any], vault: str = "Employee", tags: Optional[List[str]] = None) -> str:
        """Create an item in 1Password with optional tags"""
        command = ['op', 'item', 'create', f'--vault={vault}']

        # Add category
        if 'category' in item_data:
            command.extend(['--category', item_data['category']])

        # Add title
        if 'title' in item_data:
            command.extend(['--title', item_data['title']])

        # Add tags
        if tags:
            command.extend(['--tags', ','.join(tags)])

        # Add notes
        if 'notes' in item_data and item_data['notes']:
            command.extend(['--notes', item_data['notes']])

        # Add fields
        for field in item_data.get('fields', []):
            if field.get('value'):
                field_arg = f"{field['label']}={field['value']}"
                command.append(field_arg)

        # Add URLs
        for url in item_data.get('urls', []):
            command.extend(['--url', url])

        return OnePasswordCLI.run_command(command)


class ItemConverter:
    """Converts Bitwarden items to 1Password format"""

    TYPE_MAPPING = {
        ItemType.LOGIN: "login",
        ItemType.SECURE_NOTE: "secure note",
        ItemType.CARD: "credit card",
        ItemType.IDENTITY: "identity"
    }

    FIELD_TYPE_MAPPING = {
        FieldType.TEXT: "text",
        FieldType.HIDDEN: "concealed",
        FieldType.BOOLEAN: "text"  # 1Password doesn't have boolean fields
    }

    @staticmethod
    def convert_item(bw_item: Dict[str, Any]) -> Dict[str, Any]:
        """Convert a Bitwarden item to 1Password format"""
        item_type = ItemType(bw_item.get('type', 1))

        op_item = {
            'title': bw_item.get('name', 'Untitled'),
            'category': ItemConverter.TYPE_MAPPING.get(item_type, 'secure note'),
            'notes': bw_item.get('notes', ''),
            'fields': [],
            'urls': []
        }

        # Convert based on item type
        if item_type == ItemType.LOGIN:
            ItemConverter._convert_login(bw_item, op_item)
        elif item_type == ItemType.CARD:
            ItemConverter._convert_card(bw_item, op_item)
        elif item_type == ItemType.IDENTITY:
            ItemConverter._convert_identity(bw_item, op_item)

        # Convert custom fields
        ItemConverter._convert_custom_fields(bw_item, op_item)

        return op_item

    @staticmethod
    def _convert_login(bw_item: Dict[str, Any], op_item: Dict[str, Any]) -> None:
        """Convert login-specific fields"""
        login_data = bw_item.get('login', {})

        if login_data.get('username'):
            op_item['fields'].append({
                'label': 'username',
                'type': 'text',
                'value': login_data['username']
            })

        if login_data.get('password'):
            op_item['fields'].append({
                'label': 'password',
                'type': 'password',
                'value': login_data['password']
            })

        if login_data.get('totp'):
            op_item['fields'].append({
                'label': 'one-time password',
                'type': 'totp',
                'value': login_data['totp']
            })

        # Add URIs
        for uri_obj in login_data.get('uris', []):
            if uri_obj.get('uri'):
                op_item['urls'].append(uri_obj['uri'])

    @staticmethod
    def _convert_card(bw_item: Dict[str, Any], op_item: Dict[str, Any]) -> None:
        """Convert credit card-specific fields"""
        card_data = bw_item.get('card', {})

        field_mapping = {
            'cardholderName': 'cardholder name',
            'number': 'number',
            'brand': 'type',
            'code': 'verification number'
        }

        for bw_field, op_field in field_mapping.items():
            if card_data.get(bw_field):
                field_type = 'creditCardNumber' if bw_field == 'number' else 'text'
                if bw_field == 'code':
                    field_type = 'concealed'

                op_item['fields'].append({
                    'label': op_field,
                    'type': field_type,
                    'value': card_data[bw_field]
                })

        # Handle expiry date
        exp_month = card_data.get('expMonth')
        exp_year = card_data.get('expYear')
        if exp_month and exp_year:
            expiry = f"{exp_year}{exp_month:02d}"
            op_item['fields'].append({
                'label': 'expiry date',
                'type': 'monthYear',
                'value': expiry
            })

    @staticmethod
    def _convert_identity(bw_item: Dict[str, Any], op_item: Dict[str, Any]) -> None:
        """Convert identity-specific fields"""
        identity_data = bw_item.get('identity', {})

        identity_fields = [
            'title', 'firstName', 'middleName', 'lastName',
            'address1', 'address2', 'address3', 'city', 'state',
            'postalCode', 'country', 'company', 'email', 'phone',
            'ssn', 'username', 'passportNumber', 'licenseNumber'
        ]

        for field in identity_fields:
            if identity_data.get(field):
                op_item['fields'].append({
                    'label': field,
                    'type': 'text',
                    'value': identity_data[field]
                })

    @staticmethod
    def _convert_custom_fields(bw_item: Dict[str, Any], op_item: Dict[str, Any]) -> None:
        """Convert custom fields"""
        for field in bw_item.get('fields', []):
            if field.get('name') and field.get('value') is not None:
                field_type = FieldType(field.get('type', 0))
                op_field_type = ItemConverter.FIELD_TYPE_MAPPING.get(field_type, 'text')

                op_item['fields'].append({
                    'label': field['name'],
                    'type': op_field_type,
                    'value': str(field['value'])
                })


class MultiFolderMigrator:
    """Main class for handling multi-folder vault migration with tagging and deletion support"""

    def __init__(self, folder_names: List[str], dry_run: bool = False, vault_name: str = "Employee",
                 tag: Optional[str] = None, delete_existing: bool = False):
        self.folder_names = folder_names
        self.dry_run = dry_run
        self.vault_name = vault_name
        self.tag = tag
        self.delete_existing = delete_existing
        self.stats = MigrationStats()
        self.bw_cli = BitwardenCLI()
        self.op_cli = OnePasswordCLI()
        self.converter = ItemConverter()
        self.log = ColorLogger()
        self.target_folders: List[BitwardenFolder] = []

    def check_dependencies(self) -> None:
        """Check if required CLI tools are available"""
        self.log.info("Checking dependencies...")

        for tool in ['bw', 'op', 'jq']:
            try:
                subprocess.run([tool, '--version'],
                             capture_output=True, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.log.error(f"{tool} is not installed or not in PATH")
                sys.exit(1)

        self.log.success("All dependencies found")

    def check_authentication(self) -> None:
        """Check authentication status for both CLIs"""
        self.log.info("Checking authentication status...")

        if not self.op_cli.check_auth():
            self.log.error("Not signed into 1Password CLI. Please run: op signin")
            sys.exit(1)
        self.log.success("1Password CLI authenticated")

        if not self.bw_cli.check_auth():
            self.log.error("Bitwarden CLI is not unlocked. Please run: bw unlock")
            sys.exit(1)
        self.log.success("Bitwarden CLI authenticated and unlocked")

    def validate_arguments(self) -> None:
        """Validate command line arguments"""
        if self.delete_existing and not self.tag:
            self.log.error("--delete flag requires --tag to be specified")
            sys.exit(1)

        if self.tag:
            # Validate tag format (basic validation)
            if not self.tag.replace('-', '').replace('_', '').replace(' ', '').isalnum():
                self.log.warning(f"Tag '{self.tag}' contains special characters that might cause issues")

    def list_available_folders(self) -> None:
        """List all available folders in Bitwarden"""
        try:
            folders = self.bw_cli.list_folders()

            print("\nAvailable folders in Bitwarden:")
            print("-" * 40)
            for folder in folders:
                print(f"  • {folder.name}")
            print()

        except CLIError as e:
            self.log.error(f"Failed to list folders: {e}")

    def validate_folders(self) -> bool:
        """Validate that all specified folders exist"""
        try:
            self.target_folders = self.bw_cli.find_folders_by_names(self.folder_names)

            self.log.success(f"Found {len(self.target_folders)} folders:")
            for folder in self.target_folders:
                self.log.info(f"  • {folder.name}")

            return True

        except CLIError as e:
            self.log.error(str(e))
            self.list_available_folders()
            return False

    def validate_vault(self) -> bool:
        """Validate that the target 1Password vault exists"""
        try:
            available_vaults = self.op_cli.list_vaults()

            if self.vault_name not in available_vaults:
                self.log.error(f"Vault '{self.vault_name}' not found in 1Password")
                self.log.info(f"Available vaults: {', '.join(available_vaults)}")
                return False

            self.log.success(f"Target vault validated: '{self.vault_name}'")
            return True

        except CLIError as e:
            self.log.warning(f"Could not validate vault (will attempt to use anyway): {e}")
            return True  # Continue anyway as vault might exist

    def delete_existing_items(self) -> None:
        """Delete existing items with the specified tag"""
        if not self.tag:
            return

        self.log.delete_header()
        self.log.info(f"Searching for items with tag '{self.tag}' in vault '{self.vault_name}'...")

        try:
            existing_items = self.op_cli.list_items_by_tag(self.tag, self.vault_name)

            if not existing_items:
                self.log.info(f"No items found with tag '{self.tag}'")
                return

            self.log.warning(f"Found {len(existing_items)} items with tag '{self.tag}'")

            if not self.dry_run:
                # Confirm deletion
                self.log.warning("The following items will be PERMANENTLY DELETED:")
                for item in existing_items:
                    self.log.warning(f"  • {item.title}")

                response = input(f"\nDELETE {len(existing_items)} items? (y/N): ").strip().lower()
                if response not in ['y', 'yes']:
                    self.log.info("Deletion cancelled by user")
                    sys.exit(0)

            # Delete items
            for item in existing_items:
                if self.dry_run:
                    self.log.delete(f"[DRY RUN] Would delete: {item.title}")
                    self.stats.deleted_items += 1
                else:
                    try:
                        self.op_cli.delete_item(item.id, self.vault_name)
                        self.log.delete(f"Deleted: {item.title}")
                        self.stats.deleted_items += 1
                    except CLIError as e:
                        self.log.error(f"Failed to delete '{item.title}': {e}")

            if self.stats.deleted_items > 0:
                action = "Would delete" if self.dry_run else "Deleted"
                self.log.success(f"{action} {self.stats.deleted_items} items with tag '{self.tag}'")

        except CLIError as e:
            self.log.error(f"Failed to delete existing items: {e}")
            sys.exit(1)

    def migrate_folder(self, folder: BitwardenFolder) -> FolderStats:
        """Migrate items from a single folder"""
        folder_stats = FolderStats(folder_name=folder.name)

        self.log.folder_header(folder.name)
        self.log.info(f"Fetching items from folder '{folder.name}'...")

        try:
            items = self.bw_cli.list_items(folder.id)
            folder_stats.total_items = len(items)

            self.log.info(f"Found {folder_stats.total_items} items in folder '{folder.name}'")

            if folder_stats.total_items == 0:
                self.log.warning(f"No items found in folder '{folder.name}'")
                return folder_stats

            # Process each item
            for i, item in enumerate(items, 1):
                item_name = item.get('name', 'Untitled')

                # Filter items by prefix 'pymirror-test:'
                if not item_name.startswith('pymirror-test:'):
                    self.log.info(f"Skipping item {i}/{folder_stats.total_items}: {item_name} (does not match prefix)")
                    folder_stats.skipped += 1
                    continue

                self.log.info(f"Processing item {i}/{folder_stats.total_items}: {item_name}")

                try:
                    # Convert item
                    op_item = self.converter.convert_item(item)

                    if self.dry_run:
                        tag_info = f" with tag '{self.tag}'" if self.tag else ""
                        self.log.info(f"[DRY RUN] Would create: {item_name}{tag_info}")
                        folder_stats.successful += 1
                    else:
                        # Create item in 1Password with tags
                        tags = [self.tag] if self.tag else None
                        self.op_cli.create_item(op_item, self.vault_name, tags)

                        tag_info = f" with tag '{self.tag}'" if self.tag else ""
                        self.log.success(f"Created item: {item_name}{tag_info}")
                        folder_stats.successful += 1

                except CLIError as e:
                    self.log.error(f"Failed to create item '{item_name}': {e}")
                    folder_stats.failed += 1
                except Exception as e:
                    self.log.error(f"Unexpected error processing '{item_name}': {e}")
                    folder_stats.failed += 1

        except CLIError as e:
            self.log.error(f"Failed to fetch items from folder '{folder.name}': {e}")
            folder_stats.failed = 1  # Mark folder as failed

        return folder_stats

    def migrate_all_folders(self) -> None:
        """Migrate items from all specified folders"""
        self.log.info("Starting multi-folder migration...")

        # Sync Bitwarden vault first
        try:
            self.bw_cli.sync()
            self.log.success("Bitwarden vault synced")
        except Exception as e:
            self.log.warning(f"Failed to sync Bitwarden vault: {e}")

        # Process each folder
        for i, folder in enumerate(self.target_folders, 1):
            self.log.info(f"\n--- Processing folder {i}/{len(self.target_folders)} ---")

            folder_stats = self.migrate_folder(folder)
            self.stats.folder_stats.append(folder_stats)

            # Show folder summary
            if folder_stats.total_items > 0:
                success_rate = (folder_stats.successful / folder_stats.total_items) * 100
                self.log.info(f"Folder '{folder.name}' completed: "
                            f"{folder_stats.successful}/{folder_stats.total_items} "
                            f"({success_rate:.1f}% success rate)")
            else:
                self.log.info(f"Folder '{folder.name}' completed: No items found")

    def print_summary(self) -> None:
        """Print comprehensive migration summary"""
        print("\n" + "="*70)
        print("MULTI-FOLDER MIGRATION SUMMARY")
        print("="*70)

        print(f"Target vault: {self.vault_name}")
        print(f"Folders processed: {len(self.stats.folder_stats)}")
        if self.tag:
            print(f"Tag applied: {self.tag}")
        if self.delete_existing:
            print(f"Items deleted: {self.stats.deleted_items}")
        print()

        # Per-folder breakdown
        print("Per-folder results:")
        print("-" * 50)
        for folder_stats in self.stats.folder_stats:
            if folder_stats.total_items > 0:
                success_rate = (folder_stats.successful / folder_stats.total_items) * 100
                print(f"  {folder_stats.folder_name}:")
                print(f"    Items: {folder_stats.total_items}")
                print(f"    Successful: {folder_stats.successful}")
                print(f"    Failed: {folder_stats.failed}")
                print(f"    Success rate: {success_rate:.1f}%")
            else:
                print(f"  {folder_stats.folder_name}: No items found")
            print()

        # Overall summary
        print("Overall totals:")
        print("-" * 50)
        if self.delete_existing and self.stats.deleted_items > 0:
            delete_action = "Would delete" if self.dry_run else "Deleted"
            print(f"{delete_action} items: {self.stats.deleted_items}")
        print(f"Total items migrated: {self.stats.total_items}")
        print(f"Total successful: {self.stats.total_successful}")
        print(f"Total failed: {self.stats.total_failed}")

        if self.stats.total_items > 0:
            overall_success_rate = (self.stats.total_successful / self.stats.total_items) * 100
            print(f"Overall success rate: {overall_success_rate:.1f}%")
        else:
            print("Overall success rate: N/A (no items found)")

    def run(self) -> None:
        """Run the complete migration process"""
        print("="*80)
        print("BITWARDEN MULTI-FOLDER TO 1PASSWORD EMPLOYEE VAULT MIGRATION")
        print("="*80)

        if self.dry_run:
            self.log.warning("Running in DRY RUN mode - no items will be created or deleted")

        self.log.info(f"Source folders: {', '.join(self.folder_names)}")
        self.log.info(f"Target vault: {self.vault_name}")
        if self.tag:
            self.log.info(f"Tag to apply: {self.tag}")
        if self.delete_existing:
            self.log.warning("Delete mode enabled - existing items with tag will be removed")

        self.validate_arguments()
        self.check_dependencies()
        self.check_authentication()

        # Validate folders and vault
        if not self.validate_folders():
            return

        if not self.validate_vault():
            return

        # Confirm before proceeding
        if not self.dry_run:
            print()
            if self.delete_existing:
                self.log.warning("This script will:")
                self.log.warning(f"1. DELETE all existing items with tag '{self.tag}' in vault '{self.vault_name}'")
                self.log.warning("2. Migrate ALL items from the following folders:")
                for folder_name in self.folder_names:
                    self.log.warning(f"   • {folder_name}")
                if self.tag:
                    self.log.warning(f"3. Apply tag '{self.tag}' to all migrated items")
            else:
                self.log.warning("This script will migrate ALL items from the following folders:")
                for folder_name in self.folder_names:
                    self.log.warning(f"  • {folder_name}")
                self.log.warning(f"All items will be created in the '{self.vault_name}' vault in 1Password.")
                if self.tag:
                    self.log.warning(f"Tag '{self.tag}' will be applied to all migrated items.")

            self.log.warning("Make sure you have backups of both vaults before proceeding.")

            response = input("\nDo you want to continue? (y/N): ").strip().lower()
            if response not in ['y', 'yes']:
                self.log.info("Migration cancelled by user")
                return

        # Delete existing items if requested
        if self.delete_existing:
            self.delete_existing_items()

        # Migrate folders
        self.migrate_all_folders()
        self.print_summary()

        if self.stats.total_failed == 0:
            self.log.success("Multi-folder migration completed successfully!")
        else:
            self.log.warning(f"Multi-folder migration completed with {self.stats.total_failed} failures")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="Migrate items from multiple Bitwarden folders to 1Password employee vault with tagging and deletion support",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic migration with tagging
  python bw_multi_folder_migration.py --folders "Work" "Development" --tag "bitwarden-sync"

  # Re-sync (delete existing tagged items and migrate fresh)
  python bw_multi_folder_migration.py --folders "Work" --tag "work-sync" --delete

  # Test run with deletion
  python bw_multi_folder_migration.py --folders "Work" --tag "test" --delete --dry-run

  # Multiple folders with custom vault
  python bw_multi_folder_migration.py --folders "Dev" "QA" "Prod" --tag "environments" --vault "Shared"

  # List available folders
  python bw_multi_folder_migration.py --list-folders
        """
    )

    # Multiple folders support
    parser.add_argument(
        '--folders',
        nargs='+',
        help='Names of the Bitwarden folders to migrate (case-insensitive)'
    )

    # Single folder support (backward compatibility)
    parser.add_argument(
        '--folder',
        help='Name of a single Bitwarden folder to migrate (case-insensitive)'
    )

    parser.add_argument(
        '--tag',
        help='Tag to apply to migrated items in 1Password (recommended for re-sync scenarios)'
    )

    parser.add_argument(
        '--delete',
        action='store_true',
        help='Delete existing items with the specified tag before migration (requires --tag)'
    )

    parser.add_argument(
        '--list-folders',
        action='store_true',
        help='List all available folders in Bitwarden and exit'
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Test run without actually creating or deleting items in 1Password'
    )

    parser.add_argument(
        '--vault',
        default='Employee',
        help='1Password vault name to create items in (default: Employee)'
    )

    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    # Handle list folders request
    if args.list_folders:
        print("Listing available Bitwarden folders...")
        try:
            migrator = MultiFolderMigrator(["dummy"], vault_name=args.vault)
            migrator.check_dependencies()
            migrator.check_authentication()
            migrator.list_available_folders()
        except Exception as e:
            print(f"Error listing folders: {e}")
            sys.exit(1)
        return

    # Determine folder names to process
    folder_names = []
    if args.folders:
        folder_names.extend(args.folders)
    if args.folder:
        folder_names.append(args.folder)

    # Require at least one folder
    if not folder_names:
        parser.error("At least one folder must be specified using --folders or --folder "
                    "(or use --list-folders to see available folders)")

    # Remove duplicates while preserving order
    folder_names = list(dict.fromkeys(folder_names))

    migrator = MultiFolderMigrator(
        folder_names=folder_names,
        dry_run=args.dry_run,
        vault_name=args.vault,
        tag=args.tag,
        delete_existing=args.delete
    )

    try:
        migrator.run()
    except KeyboardInterrupt:
        print("\n\nMigration interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.exception("Unexpected error during migration")
        print(f"\nUnexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
