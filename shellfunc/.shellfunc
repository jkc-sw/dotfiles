#!/bin/sh

# Declare function to add path
# https://unix.stackexchange.com/questions/14895/duplicate-entries-in-path-a-problem
# Answer from: Gilles
# answered Jun 13 '11 at 8:34
addThisPath() {
    case ":$PATH:" in
    *":$1:"*) :;; # already there
    *) PATH="$1:$PATH";; # or PATH="$PATH:$1"
    esac
}

BOLD_TEXT='\e[1m'
YELLO_BOLD_TEXT='\e[1;93m'
GREEN_BOLD_TEXT='\e[1;92m'
BLUE_BOLD_TEXT='\e[1;96m'
RED_BOLD_TEXT='\e[1;91m'
PLAIN='\e[0m'
function echobold() {
    echo -e "${BOLD_TEXT}$1${PLAIN}"
}
function echosubcommand() {
    echo -e "${BLUE_BOLD_TEXT}$1${PLAIN}"
}
function echoinfo() {
    echo -e "${BOLD_TEXT}INFO${PLAIN}: $1"
}
function echoerror() {
    echo -e "${RED_BOLD_TEXT}ERROR${PLAIN}: $1" >&2
}
function echosuccess() {
    echo -e "${GREEN_BOLD_TEXT}SUCCESS${PLAIN}: $1"
}
function echowarning() {
    echo -e "${YELLO_BOLD_TEXT}WARNING${PLAIN}: $1"
}

# # Awesome stuff from https://unix.stackexchange.com/a/351658
# if [ -n "$BASH" ]; then
#     LINUX_ALIAS_PATH=${BASH_SOURCE}
# elif [ -n "$ZSH_NAME" ]; then
#     LINUX_ALIAS_PATH=${(%):-%x}
# fi
# if [ -z "$LINUX_ALIAS_PATH" ]; then
#     echo "Cannod find LINUX_ALIAS_PATH in the env var"
# fi
# export LINUX_ALIAS_DIR="${LINUX_ALIAS_PATH%/*}"

addThisPath "$HOME/.cargo/bin"
addThisPath "$HOME/.local/bin"
addThisPath "/usr/local/sbin"
addThisPath "/usr/sbin"
addThisPath "/opt/TurboVNC/bin"
addThisPath "$HOME/.local/p4v/bin"

# some configuration to shell
export TERM=xterm-256color
export EDITOR=nvim
export LANG=en_US.UTF-8

# To have xmonad and matlab play nicely
export _JAVA_AWT_WM_NONREPARENTING=1

# To be save
alias rm='rm -I'

# Getting brew
if [[ -x "/home/linuxbrew/.linuxbrew/bin/brew" ]]; then
    eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
fi

# Getting nix-env
if [[ -r "$HOME/.nix-profile/etc/profile.d/nix.sh" ]]; then
    . "$HOME/.nix-profile/etc/profile.d/nix.sh"
    alias ni=nix-env
fi

# Need to source conda
pomo() {
    conda activate "$HOME/miniconda3/envs/dev_env_ansible"
    pomodoro "$@"
}

# Add the tmux command to start the tmux session
rt() (
    cd "$HOME/repos/dev-env-ansible"
    ./rr.sh tmux
)

# @brief Run the tmux routine
# @param name - tmux name
# @param cb - callback to configure the tmux session at creation time
# @param label - The label to start alternative client
function tmux_attach() {
    name="$1"
    cb="$2"
    label="$3"

    if [[ -z "$name" ]]; then
        echowarning "Nothing to be done"
        return 1
    fi

    if [[ -n "$name" && -z "$label" ]]; then
        if ! (tmux ls | grep -q "$name"); then
            tmux new-session -s "$name" -d

            # if there is callback, run it
            if command -v "$cb" &>/dev/null; then
                "$cb" "$name"
            fi
        fi

        tmux attach-session -t "$name"
        return 0
    fi

    # no label, nothing to be done further
    if [[ -z "$label" ]]; then
        return 0
    fi

    # store the name
    newname="$name-$label"

    # check if the session exists
    if ! (tmux ls | grep -q "$newname"); then
        tmux new-session -t "$name" -s "$newname" -d
    fi

    # attach to the session
    tmux attach-session -t "$newname"
}

# Quickly start the session
aoeu () {
    tmux_attach aoeu '' "$1"
}

# configuration to rg and fd
export RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"
if command -v fd >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='fd --follow --hidden --type file'
    export FZF_ALT_C_COMMAND="fd --follow --hidden --type directory"
elif command -v fdfind >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='fdfind --follow --hidden --type file'
    export FZF_ALT_C_COMMAND="fdfind --follow --hidden --type directory"
    alias fd=fdfind
fi
export FZF_DEFAULT_OPTS="--color=dark --height=50%"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# handle shell specific
add_shell_specific() {
    forshell="$1"
    eval "$(starship init "$forshell")"
    eval "$(zoxide init --cmd 'c' "$forshell")"

    # Handle the fzf
    fzf_dir="$HOME/.local/share/nvim/site/pack/packer/start/fzf"
    fzf_bindir="$fzf_dir/bin"
    fzf_shelldir="$fzf_dir/shell"
    if test -d "$fzf_bindir"; then
        addThisPath "$fzf_bindir"
        if test -n "$forshell"; then
            # # shellcheck source=/dev/null
            # . "$fzf_shelldir/completion.$forshell" # Too slow

            # shellcheck source=/dev/null
            . "$fzf_shelldir/key-bindings.$forshell"
        fi
    fi
}

# @brief Source the environment
nv() {
    if test -d "$HOME/miniconda3/envs/dev_env_ansible2"; then
        conda activate "$HOME/miniconda3/envs/dev_env_ansible2"
    fi

    if test -d "$HOME/miniconda3/envs/dev_env_ansible"; then
        conda activate --stack "$HOME/miniconda3/envs/dev_env_ansible"
    fi

    # Setup the dev env
    sdev

    if test -n "$TMUX"; then
        # Get current panes
        beforepanenum="$(tmux list-panes | wc -l)"

        # run the tswitch
        tswitch

        # Get after panes
        afterpanenum="$(tmux list-panes | wc -l)"

        # Send the source command only when creating new pane
        if test "$afterpanenum" -eq 2 -a "$beforepanenum" -eq 1; then
            tmux send-keys -t :.+ 'nv' Enter
        fi
    fi
}

# shortcut to start nvim
n() {
    nv

    if command -v nvim >/dev/null 2>&1; then
        nvim -c "lua require'jerry.lsp.config'.alternative_lsp{}" "$@"
    fi
}

# Change keyboard layout
AOE() {
    doas localectl set-x11-keymap us '' '' us
}
ASD() {
    doas localectl set-x11-keymap us '' '' dvorak
}

# shortcut to start nvim with host being a tmux
nvt() {
    TOCLIP_HOST_TMUX=2 n "$@"
}

# add a command to start docker instance
dr() {
    ~/repos/dev-env-ansible/rr.sh use u20 "$@"
}

# add a command to start podman docker instance
pd() {
    ~/repos/dev-env-ansible/rr.sh use poddock "$@"
}

# try to use bat in man
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

# nvm stuff
export NVM_DIR="$HOME/.nvm"

# asdf dir
export ASDF_DIR="$HOME/repos/asdf"

# function to update plugin
update_zsh_plugins() { (
    if test -d "$ZSH_PLUG_DIR"; then
        cd "$ZSH_PLUG_DIR/plugins" || return
        for d in $(fd -t d -d 1); do
            echo "Git pull $d"
            git -C "$d" pull -q
        done
    fi
) }

# Source some tools that I don't use often
sdev() {
    if ! command -v nvm >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$NVM_DIR/nvm.sh"  # This loads nvm
        # shellcheck source=/dev/null
        . "$NVM_DIR/bash_completion"  # Too slow
        # shellcheck source=/dev/null
        . "$ASDF_DIR/asdf.sh"
    fi
}

# Need an easier way to handle the pass
mpass() {
    # check if the pass exist
    if ! type -p pass &>/dev/null; then
        echo 'Cannot find pass in the PATH' >&2
        return 0
    fi

    # check nargs
    case "$#" in
    0)
        pass
        return 0
        ;;
    1)
        pass "$1" | tr -d '\r\n' | toclip
        return 0
        ;;
    *)
        pass "$@"
        return 0
        ;;
    esac
}

# work around the sudo
if ! type -p doas &>/dev/null; then
    alias doas=sudo
fi

# Add the fcitx support
if command -v fcitx >/dev/null 2>&1; then
    export GTK_IM_MODULE=fcitx
    export QT_IM_MODULE=fcitx
    export XMODIFIERS=@im=fcitx
    export GLFW_IM_MODULE='ibus kitty'
fi

export_myvnc_display() {
    # Try to find the display
    displaystart=false
    while IFS='' read -r li; do
        # Print info
        if [[ "$displaystart" == 'true' ]]; then
            # Processing
            if [[ "$li" =~ ^(:[0-9]+) ]]; then
                [[ -n $BASH_VERSION ]] && reMatch=( "${BASH_REMATCH[@]}" )
                [[ -n $ZSH_VERSION ]]  && reMatch=( "$MATCH" "${match[@]}" )
                # Only do this if I have a result
                if [[ -n "${reMatch[1]}" ]]; then
                    # export it and stop
                    export DISPLAY="${reMatch[1]}"
                    break
                fi
            fi
            # stop parsing
            if [[ "$li" =~ ^\ *$ ]]; then
                break
            fi
        fi
        # find display start
        if [[ "$li" =~ ^X\ DISPLAY\ # ]]; then
            displaystart=true
            continue
        fi
    done < <(myvnc)
}

# never run these
_init_gpg_pass() {

    # Need these
    if [ -z "$MY_GPG_DIR" ]; then
        echo 'MY_GPG_DIR not found'
    fi
    if [ -z "$MY_PASS_ID" ]; then
        echo 'MY_PASS_ID not found'
    fi
    if [ -z "$PASSWORD_STORE_DIR" ]; then
        echo 'MY_PASS_ID not found'
    fi

    echoerror "Code should never get here"
    return 1

    # Check if the key is there
    if gpg --list-keys | grep -q "$MY_PASS_ID"; then
        return 0
    fi

    # Check if the files are there
    if [ ! -r "$MY_GPG_DIR/p.txt" ] || [ ! -r "$MY_GPG_DIR/s.txt" ]; then
        echoerror "Cannot find the key to import from '$MY_GPG_DIR'"
        return 1
    fi

    # Improt the key
    gpg --import "$MY_GPG_DIR/p.txt"
    gpg --import "$MY_GPG_DIR/s.txt"

    # Validate the keys
    gpg --list-keys
    gpg --list-secret-keys

    # trust the key before it can be used an another computer
    gpg --edit-key "$MY_PASS_ID"  # Then enter "trust"

    # Generate a key
    gpg --quick-generate-key "$MY_PASS_ID"
    # gpg --generate-key

    # Backup key
    if [ -d "$MY_GPG_DIR" ]; then
        echoerror "Please map the folder '$MY_GPG_DIR'"
        return 1
    fi

    # Export the keys
    gpg --export --output "$MY_GPG_DIR/p.txt" --armor "$MY_PASS_ID"
    # Check the file exist
    if [[ ! -r "$MY_GPG_DIR/p.txt" ]]; then
        echoerror 'Fail to export the p key'
        return 1
    fi
    gpg --export-secret-keys --output "$MY_GPG_DIR/s.txt" --armor "$MY_PASS_ID"
    if [[ ! -r "$MY_GPG_DIR/s.txt" ]]; then
        echoerror 'Fail to export the s key'
        return 1
    fi

    # Init the store
    pass init "$MY_PASS_ID"

    # Add a key
    pass insert --echo somepassword
}
