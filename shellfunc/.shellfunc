#!/bin/sh

# Declare function to add path
# https://unix.stackexchange.com/questions/14895/duplicate-entries-in-path-a-problem
# Answer from: Gilles
# answered Jun 13 '11 at 8:34
addThisPath() {
    case ":$PATH:" in
    *":$1:"*) :;; # already there
    *) PATH="$1:$PATH";; # or PATH="$PATH:$1"
    esac
}

# # Awesome stuff from https://unix.stackexchange.com/a/351658
# if [ -n "$BASH" ]; then
#     LINUX_ALIAS_PATH=${BASH_SOURCE}
# elif [ -n "$ZSH_NAME" ]; then
#     LINUX_ALIAS_PATH=${(%):-%x}
# fi
# if [ -z "$LINUX_ALIAS_PATH" ]; then
#     echo "Cannod find LINUX_ALIAS_PATH in the env var"
# fi
# export LINUX_ALIAS_DIR="${LINUX_ALIAS_PATH%/*}"

addThisPath "$HOME/.cargo/bin"
addThisPath "$HOME/.local/bin"
addThisPath "/usr/local/sbin"
addThisPath "/usr/sbin"
addThisPath "/opt/TurboVNC/bin"
addThisPath "$HOME/.local/p4v/bin"

# some configuration to shell
export TERM=xterm-256color
export EDITOR=nvim
export LANG=en_US.UTF-8

# To have xmonad and matlab play nicely
export _JAVA_AWT_WM_NONREPARENTING=1

# To be save
alias rm='rm -I'

# Need to source conda
pomo() {
    conda activate "$HOME/miniconda3/envs/dev_env_ansible"
    pomodoro "$@"
}

# Add the tmux command to start the tmux session
rt() (
    cd "$HOME/repos/dev-env-ansible"
    ./rr.sh tmux
)

# Quickly start the session
function aoeu() {
    name=aoeu
    if [[ "$#" -eq 0 ]]; then
        if ! (tmux ls | grep -q "$name"); then
            tmux new-session -s "$name" -d
        fi
        tmux attach-session -t "$name"
        return
    fi

    # need 1 arg
    if [[ $# -ne 1 ]]; then
        echo "Need to provide a suffix for attaching to the session" >&2
        exit 1
    fi

    # store the name
    newname="$name-$1"

    # check if the session exists
    if ! (tmux ls | grep -q "$newname"); then
        tmux new-session -t "$name" -s "$newname" -d
    fi

    # attach to the session
    tmux attach-session -t "$newname"
}

# configuration to rg and fd
export RIPGREP_CONFIG_PATH="$HOME/.ripgreprc"
if command -v fd >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='fd --follow --hidden --type file'
    export FZF_ALT_C_COMMAND="fd --follow --hidden --type directory"
elif command -v fdfind >/dev/null 2>&1; then
    export FZF_DEFAULT_COMMAND='fdfind --follow --hidden --type file'
    export FZF_ALT_C_COMMAND="fdfind --follow --hidden --type directory"
    alias fd=fdfind
fi
export FZF_DEFAULT_OPTS="--color=dark --height=50%"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"

# cpu managements
# alias cinfo='sudo modprobe msr && sudo cpupower frequency-info'
cinfo() {
    runsudo=doas
    if ! type -p doas &>/dev/null; then
        runsudo=sudo
    fi
    "$runsudo" modprobe msr && "$runsudo" cpupower frequency-info
}
# alias cmonitor='sudo modprobe msr && sudo turbostat --show Core,CPU,Avg_MHz,Busy%,Bzy_MHz,TSC_MHz,CoreTmp,PkgTmp,PkgWatt,RAMWatt'
cmonitor() {
    runsudo=doas
    if ! type -p doas &>/dev/null; then
        runsudo=sudo
    fi
    "$runsudo" modprobe msr && "$runsudo" turbostat --show Core,CPU,Avg_MHz,Busy%,Bzy_MHz,TSC_MHz,CoreTmp,PkgTmp,PkgWatt,RAMWatt
}
# alias cperf='sudo modprobe msr && sudo cpupower frequency-set -g performance'
cperf() {
    if test "$#" -lt 1; then
        echo "Current governor:"
        cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor | sort -u
        echo ''

        echo "Available governor:"
        cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
        echo ''

        echo 'Current Frequencies'
        cat /proc/cpuinfo | sed -n 's/cpu mhz.*: \(.*\)/\1/Ip' | sort -n | column
        echo ''

        echo "cperf: Set the cpu mode"
        echo "  [mode]: 0 means powersave, 1 means performance, or other scaling_governor"

    elif test "$#" -eq 1; then
        cmd="$1"
        if test "$cmd" = '0'; then
            cmd='powersave'
        elif test "$cmd" = '1'; then
            cmd='performance'
        fi

        runsudo=doas
        if ! type -p doas &>/dev/null; then
            runsudo=sudo
        fi
        find /sys/devices/system/cpu/ -type f -name scaling_governor | "$runsudo" xargs -I% bash -c "echo $cmd > %"
    else
    	echo "Error, there should only be 1 argument"
	return 1
    fi
}

# handle shell specific
add_shell_specific() {
    forshell="$1"
    eval "$(starship init "$forshell")"
    eval "$(zoxide init "$forshell")"

    # Handle the fzf
    fzf_dir="$HOME/.local/share/nvim/site/pack/packer/start/fzf"
    fzf_bindir="$fzf_dir/bin"
    fzf_shelldir="$fzf_dir/shell"
    if test -d "$fzf_bindir"; then
        addThisPath "$fzf_bindir"
        if test -n "$forshell"; then
            # # shellcheck source=/dev/null
            # . "$fzf_shelldir/completion.$forshell" # Too slow

            # shellcheck source=/dev/null
            . "$fzf_shelldir/key-bindings.$forshell"
        fi
    fi
}

# @brief Source the environment
nv() {
    if test -d "$HOME/miniconda3/envs/dev_env_ansible2"; then
        conda activate "$HOME/miniconda3/envs/dev_env_ansible2"
    fi

    if test -d "$HOME/miniconda3/envs/dev_env_ansible"; then
        conda activate --stack "$HOME/miniconda3/envs/dev_env_ansible"
    fi

    if test -n "$TMUX"; then
        # Get current panes
        beforepanenum="$(tmux list-panes | wc -l)"

        # run the tswitch
        tswitch

        # Get after panes
        afterpanenum="$(tmux list-panes | wc -l)"

        # Send the source command only when creating new pane
        if test "$afterpanenum" -eq 2 -a "$beforepanenum" -eq 1; then
            tmux send-keys -t :.+ 'nv' Enter
        fi
    fi
}

# shortcut to start nvim
n() {
    nv

    if command -v nvim >/dev/null 2>&1; then
        nvim -c "lua require'jerry.lsp.config'.alternative_lsp{}" "$@"
    fi
}

# shortcut to start nvim with host being a tmux
nvt() {
    TOCLIP_HOST_TMUX=2 n "$@"
}

# add a command to start docker instance
dr() {
    ~/repos/dev-env-ansible/rr.sh use u20 "$@"
}

# try to use bat in man
export MANPAGER="sh -c 'col -bx | bat -l man -p'"

# nvm stuff
export NVM_DIR="$HOME/.nvm"

# asdf dir
export ASDF_DIR="$HOME/repos/asdf"

# function to update plugin
update_zsh_plugins() { (
    if test -d "$ZSH_PLUG_DIR"; then
        cd "$ZSH_PLUG_DIR/plugins" || return
        for d in $(fd -t d -d 1); do
            echo "Git pull $d"
            git -C "$d" pull -q
        done
    fi
) }

# Source some tools that I don't use often
sdev() {
    if ! command -v nvm >/dev/null 2>&1; then
        # shellcheck source=/dev/null
        . "$NVM_DIR/nvm.sh"  # This loads nvm
        # shellcheck source=/dev/null
        . "$NVM_DIR/bash_completion"  # Too slow
        # shellcheck source=/dev/null
        . "$ASDF_DIR/asdf.sh"
    fi
}

# Need an easier way to handle the pass
mpass() {
    # check if the pass exist
    if ! type -p pass &>/dev/null; then
        echo 'Cannot find pass in the PATH' >&2
        return 0
    fi

    # check nargs
    case "$#" in
    0)
        pass
        return 0
        ;;
    1)
        pass "$1" | tr -d '\r\n' | toclip
        return 0
        ;;
    *)
        pass "$@"
        return 0
        ;;
    esac
}

# work around the sudo
if ! type -p doas &>/dev/null; then
    alias doas=sudo
fi

# Add the fcitx support
if command -v fcitx >/dev/null 2>&1; then
    export GTK_IM_MODULE=fcitx
    export QT_IM_MODULE=fcitx
    export XMODIFIERS=@im=fcitx
fi

# never run these
_init_gpg_pass() {
    # Need these
    if [ -z "$MY_GPG_DIR" ]; then
        echo 'MY_GPG_DIR not found'
    fi
    if [ -z "$MY_PASS_ID" ]; then
        echo 'MY_PASS_ID not found'
    fi

    echoerror "Code should never get here"
    return 1

    # Check if the key is there
    if gpg --list-keys | grep -q "$MY_PASS_ID"; then
        return 0
    fi

    # Check if the files are there
    if [ ! -r "$MY_GPG_DIR/p.txt" ] || [ ! -r "$MY_GPG_DIR/s.txt" ]; then
        echoerror "Cannot find the key to import from '$MY_GPG_DIR'"
        return 1
    fi

    # Improt the key
    gpg --import "$MY_GPG_DIR/p.txt"
    gpg --import "$MY_GPG_DIR/s.txt"

    # Validate the keys
    gpg --list-keys
    gpg --list-secret-keys

    # trust the key before it can be used an another computer
    gpg --edit-key "$MY_PASS_ID"  # Then enter "trust"

    # Generate a key
    gpg --quick-generate-key "$MY_PASS_ID"
    # gpg --generate-key

    # Backup key
    if [ -d "$MY_GPG_DIR" ]; then
        echoerror "Please map the folder '$MY_GPG_DIR'"
        return 1
    fi

    # Export the keys
    gpg --export --output "$MY_GPG_DIR/p.txt" --armor "$MY_PASS_ID"
    # Check the file exist
    if [[ ! -r "$MY_GPG_DIR/p.txt" ]]; then
        echoerror 'Fail to export the p key'
        return 1
    fi
    gpg --export-secret-keys --output "$MY_GPG_DIR/s.txt" --armor "$MY_PASS_ID"
    if [[ ! -r "$MY_GPG_DIR/s.txt" ]]; then
        echoerror 'Fail to export the s key'
        return 1
    fi

    # Init the store
    pass init "$MY_PASS_ID"

    # Add a key
    pass insert --echo somepassword
}
